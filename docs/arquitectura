# üèóÔ∏è ARQUITECTURA DEL SISTEMA AVSI
**Artificial Vision Stacking Inspection (AVSI)**  
*Sistema de visi√≥n artificial basado en redes neuronales convolucionales (CNN) para la verificaci√≥n autom√°tica del apilamiento de pa√±ales.*

---

## üß© 1. Tipo de Modelo Seleccionado y Justificaci√≥n

### **Modelo Principal: ResNet-18 (Transfer Learning)**
El sistema AVSI utiliza una **arquitectura ResNet-18** como red base para clasificaci√≥n binaria (apilamiento correcto vs. incorrecto).  
ResNet (Residual Network) es una **CNN profunda** que incorpora *skip connections*, lo que permite un entrenamiento m√°s estable y evita el problema de *vanishing gradients* en redes profundas.

**Justificaci√≥n t√©cnica:**
- **Transfer Learning:** Al usar pesos preentrenados en **ImageNet**, se aprovecha conocimiento previo de millones de im√°genes, mejorando la generalizaci√≥n del modelo con datasets peque√±os (100 y 1000 im√°genes).
- **Rendimiento y eficiencia:** ResNet-18 ofrece un equilibrio √≥ptimo entre **precisi√≥n (>90%)** y **velocidad (>30 FPS)**, lo cual es esencial para procesos industriales en tiempo real.
- **Compatibilidad industrial:** Su bajo costo computacional permite ejecuci√≥n en dispositivos de borde como **Raspberry Pi** o **Jetson Nano**, facilitando la integraci√≥n con celdas rob√≥ticas o sistemas PLC.
- **Escalabilidad:** La arquitectura permite extender f√°cilmente el modelo hacia ResNet-34, MobileNetV2 o YOLOv8 si el proyecto evoluciona hacia detecci√≥n en lugar de clasificaci√≥n.

---

## ‚öôÔ∏è 2. Arquitectura Detallada del Sistema

El flujo general del sistema AVSI combina procesamiento de datos, entrenamiento del modelo y despliegue de inferencias.  
La arquitectura est√° organizada en **cinco capas funcionales:**

### **1Ô∏è‚É£ Capa de Adquisici√≥n**
- Captura im√°genes mediante c√°mara industrial **SVPRO 4K** conectada a Raspberry Pi o laptop de desarrollo.
- Genera datasets almacenados en `/data/raw/` con etiquetas *good_stack* y *bad_stack*.
- Las im√°genes se preprocesan en formato RGB con resoluci√≥n est√°ndar de **224√ó224 px**.

### **2Ô∏è‚É£ Capa de Preprocesamiento**
Implementada en el notebook `02_preprocesamiento_AVSI.ipynb`, incluye:
- **Redimensionamiento y normalizaci√≥n:** Se homogeniza el tama√±o y la escala de color.  
- **Data Augmentation:** Rotaciones, flips y jitter de brillo/contraste para ampliar la muestra.  
- **Divisi√≥n estratificada:** 70% entrenamiento, 15% validaci√≥n, 15% prueba.  
- **Salida estructurada:** `/data/processed/train`, `/val`, `/test`, y `labels.csv`.

### **3Ô∏è‚É£ Capa de Modelado**
Desarrollada en `03_modelado_AVSI.ipynb`:
- Base: `torchvision.models.resnet18(weights=ResNet18_Weights.DEFAULT)`
- Se reemplaza la capa final (`fc`) con una densa de salida binaria (`Linear(in_features, 2)`).
- Optimizador **Adam**, funci√≥n de p√©rdida **CrossEntropyLoss**, y *early stopping* para prevenir sobreajuste.
- Guardado del mejor modelo como `models/best_model.pt`.

### **4Ô∏è‚É£ Capa de Optimizaci√≥n y Validaci√≥n**
En `04_optimizacion_AVSI.ipynb`:
- **Grid Search** sobre hiperpar√°metros: *lr*, *batch_size*, *weight_decay*, *freeze_backbone*.  
- An√°lisis de sensibilidad y comparaci√≥n de rendimiento.  
- Selecci√≥n autom√°tica del modelo con mayor *val_acc*.

### **5Ô∏è‚É£ Capa de Despliegue**
El modelo final se integra en una aplicaci√≥n **Streamlit**, que permite:
- Cargar im√°genes individuales o en lote.  
- Mostrar predicciones con probabilidades.  
- Exportar resultados y visualizar m√©tricas de confianza.  
- Procesamiento en tiempo real (>30 FPS).

---

## üîÑ 3. Pipeline de Datos (de Input a Output)

El flujo de informaci√≥n del sistema puede resumirse en el siguiente pipeline:


---

## üß† 4. Tecnolog√≠as y Librer√≠as Utilizadas

### **Lenguaje Base**
- **Python 3.10.14**

### **Librer√≠as Principales**
| Categor√≠a | Librer√≠a | Versi√≥n | Descripci√≥n |
|------------|-----------|----------|-------------|
| **IA y Deep Learning** | `torch` | 2.3.1 | Framework de redes neuronales |
|  | `torchvision` | 0.18.1 | Modelos preentrenados (ResNet-18) |
| **Procesamiento de im√°genes** | `opencv-python` | 4.10.0.84 | Lectura, redimensionamiento y visualizaci√≥n |
|  | `Pillow` | 10.4.0 | Manipulaci√≥n avanzada de im√°genes |
| **Ciencia de Datos** | `numpy` | 1.26.4 | C√°lculos num√©ricos y operaciones matriciales |
|  | `pandas` | 2.2.2 | Manipulaci√≥n de estructuras tabulares |
|  | `scikit-learn` | 1.5.2 | Split de datasets y m√©tricas de evaluaci√≥n |
| **Visualizaci√≥n** | `matplotlib` | 3.9.2 | Gr√°ficos de entrenamiento y m√©tricas |
|  | `plotly` | 5.23.0 | Visualizaciones interactivas |
| **Interfaz** | `streamlit` | 1.37.1 | Despliegue de interfaz interactiva web |
| **Optimizaci√≥n y utilidades** | `tqdm` | 4.66.4 | Barra de progreso en entrenamiento |
|  | `joblib` | 1.4.2 | Guardado de objetos y modelos |
| **Configuraci√≥n** | `pyyaml` | 6.0.2 | Gesti√≥n de archivos de configuraci√≥n |

### **Hardware y Entorno**
- Laptop con CPU Intel i7 (8 n√∫cleos) o Raspberry Pi 5 (8 GB RAM).  
- GPU opcional con soporte CUDA 11+ (NVIDIA).  
- Sistema operativo: Ubuntu 22.04 / Windows 11.  
- Entorno de desarrollo: **Visual Studio Code + Jupyter Notebook**.  

---

## üîç 5. Resumen Arquitect√≥nico

| Componente | Descripci√≥n T√©cnica |
|-------------|--------------------|
| **Dataset** | Im√°genes RGB (224x224 px), 2 clases (good_stack / bad_stack) |
| **Modelo** | CNN ResNet-18 con *transfer learning* |
| **Entrenamiento** | CrossEntropyLoss, optimizador Adam, early stopping |
| **Evaluaci√≥n** | Accuracy, Confusion Matrix, Classification Report |
| **Optimizaci√≥n** | Grid Search (lr, batch_size, weight_decay) |
| **Interfaz** | Streamlit para predicci√≥n e interpretaci√≥n visual |
| **Desempe√±o esperado** | mAP ‚â• 0.70, IoU > 0.50, FPS > 30 |

---

## üìà 6. Conclusi√≥n
La arquitectura t√©cnica de **AVSI** fue dise√±ada bajo los principios de **modularidad, reproducibilidad y eficiencia industrial**, permitiendo su integraci√≥n futura con sistemas de control y automatizaci√≥n (PLC, SCADA o celdas robotizadas).  
El uso de **ResNet-18** con *transfer learning* asegura un equilibrio entre desempe√±o y costo computacional, posicionando el sistema como un **prototipo s√≥lido para la industria 4.0**.

---

